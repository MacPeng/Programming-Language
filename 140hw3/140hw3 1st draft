--Problem 1 
myremoveduplicates :: Eq a => [a] -> [a]
myremoveduplicates list
	| null list 					= list    --empty list = list
	| elem (head list) (tail list)	= myremoveduplicates (tail list)   --check if head is the same as the tail
	| otherwise						= (head list) : myremoveduplicates (tail list)   --check the head element and the rest of the elements in the list





--problem 2  list1 is the first input list  list2 is the 2nd input list
myintersection :: Eq a => [a] -> [a] -> [a]
myintersection list1 list2
	| null list1 				    = [] 
	| elem (head list1) list2	    = (head list1) : (myintersection (tail list1) list2)
	| otherwise						= myintersection (tail list1) list2





--problem 3
mynthtail :: Int -> [a]-> [a]
mynthtail n list --n is the size of the list
	| n == 0 			            = list
	| otherwise 		            = mynthtail (n-1) (tail list)

mynthtail_pm :: Int -> [a] -> [a]
mynthtail_pm 0 list 	            = list
mynthtail_pm n (x:xs) 	            = mynthtail_pm (n-1) xs




--problem 4
mylast :: [a] -> [a]
mylast list 
	| null list 		= list
 	| null (tail list)	= list
 	| otherwise 		= mylast (tail list) --call the last element in the list in this case






 
--problem 5
myreverse :: [a] -> [a]
myreverse list
	| null list 		= list
	| otherwise		    = myreverse_helper list []

myreverse_helper :: [a] -> [a] -> [a]
myreverse_helper list1 list2 
	| null list1 	    = list2
	| otherwise 	    = myreverse_helper (tail list1) ((head list1):list2)






